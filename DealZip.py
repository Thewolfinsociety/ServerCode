#coding:utf-8# -*- coding: UTF-8 -*-# @Time : 2019/11/26 16:22# @Author : litao# @File : OperateDB.py version3'''更新至Python3'''import osimport sqlite3import jsonimport tornado.escapeimport tornado.ioloopimport tornado.webfrom tornado.options import define, options, parse_command_linefrom tornado.web import RequestHandlerimport zipfileimport loggingimport timedefine("port", default=8001, help="run on the given port", type=int)base_dir = os.path.abspath(os.path.join(os.getcwd(),'..'))filepath = base_dir +'\\Python\\sqlitedb\\QdSoftListDb.db'ZipPath = base_dir+'\\nginx-1.0.11\\nginx-1.0.11\html\\zippath\\'HtmlPath = base_dir+'\\nginx-1.0.11\\nginx-1.0.11\html\\'class BaseHandler(RequestHandler):    def set_default_headers(self):        self.set_header("Access-Control-Allow-Origin", "*")        self.set_header("Access-Control-Allow-Headers",                        "x-requested-with,access_token")  # 这里要填写上请求带过来的Access-Control-Allow-Headers参数，如access_token就是我请求带过来的参数        self.set_header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE")  # 请求允许的方法        self.set_header("Access-Control-Max-Age", "3600")  # 用来指定本次预检请求的有效期，单位为秒，，在此期间不用发出另一条预检请求。    # 定义一个响应OPTIONS 请求，不用作任务处理    def options(self):        pass# 退出程序操作class ExitSystem(tornado.web.RequestHandler):    def get(self, *args, **kwargs):        print("***服务器退出***")        os._exit(0)  # 退出程序def maintest():    print(filepath)    QdSoftListDb = DbDataBase(filepath)    QdSoftListDb.additem('123','你的那个腾讯云win服务器上')'''ZFile 用于文件解压缩，压缩'''class ZFile(object):    def __init__(self, filename, mode='r', basedir=''):        self.filename = filename        self.mode = mode        if self.mode in ('w', 'a'):            self.zfile = zipfile.ZipFile(filename, self.mode, compression=zipfile.ZIP_DEFLATED)        else:            self.zfile = zipfile.ZipFile(filename, self.mode)        self.basedir = basedir        if not self.basedir:            self.basedir = os.path.dirname(filename)    def addfile(self, path, arcname=None):        path = path.replace('//', '/')        if not arcname:            if path.startswith(self.basedir):                arcname = path[len(self.basedir):]            else:                arcname = ''        self.zfile.write(path, arcname)    def addfiles(self, paths):        for path in paths:            if isinstance(path, tuple):                self.addfile(*path)            else:                self.addfile(path)    def close(self):        self.zfile.close()    def extract_to(self, path):        for p in self.zfile.namelist():            self.extract(p, path)    def extract(self, filename, path):        if not filename.endswith('/'):            f = os.path.join(path, filename)            try:                f = f.encode("cp437").decode('gbk')            except:                pass            dir = os.path.dirname(f)            if not os.path.exists(dir):                os.makedirs(dir)            open(f, 'wb').write(self.zfile.read(filename))def extractZip(zfile, path):    z = ZFile(zfile)    z.extract_to(path)    z.close()class Unzip(BaseHandler):    def get(self, *args, **kwargs):        result = {'result':0}        filename = self.get_argument('filename', None)        if not os.path.exists(ZipPath):            os.makedirs(ZipPath)        filepath = ZipPath + '\\' + filename        if not os.path.exists(filepath):            self.write(json.dumps(result,ensure_ascii=False).encode('utf8'))        else:            extractZip(filepath, HtmlPath)            result['result'] = 1            self.write(json.dumps(result, ensure_ascii=False).encode('utf8'))def get_file_ext(filename):    '''    :param filename: '123.txt'    :return: txt    '''    if filename.find('.')<0:        return ''    return  filename[filename.index('.') + 1:]class ReadZipPath(BaseHandler):    def get(self, *args, **kwargs):        result = {'result': 0}        if not os.path.exists(ZipPath):            os.makedirs(ZipPath)        files = os.listdir(ZipPath)        files = [files[i] for i in range(len(files)) if (get_file_ext(files[i])).lower()=='zip']        result['files'] = files        result['result'] = 1        self.write(json.dumps(result,ensure_ascii=False).encode('utf8'))class DealZip(BaseHandler):    def get(self, *args, **kwargs):        result = {'result': 0}        filename = self.get_argument('filename', None)        filepath = ZipPath + '\\' + filename        if not os.path.exists(filepath):            self.write(json.dumps(result, ensure_ascii=False).encode('utf8'))        else:            os.remove(filepath)            result['result'] = 1            self.write(json.dumps(result, ensure_ascii=False).encode('utf8'))class UploadFile(BaseHandler):    def post(self, *args, **kwargs):        upload_path = os.path.join(os.path.dirname(__file__), 'UploadFiles')  # 文件的暂存路径        if not os.path.exists(upload_path):            os.makedirs(upload_path)        name = self.get_argument('hello', None)        print (name)        file_metas = self.request.files.get('file', None)        # file_metas = self.request.files['file']  # 提取表单中‘name’为‘file’的文件元数据        if not file_metas:            ret = {'result': '0', 'information': '参数错误'}            Result = json.dumps(ret)            self.write(Result)        for meta in file_metas:            filename = meta['filename']            # guid = str(uuid.uuid1())  # 唯一标识符guid            # guid = ''.join(guid.split('-'))            # filename = guid            filepath = os.path.join(upload_path, filename)            # 有些文件需要已二进制的形式存储，实际中可以更改            with open(filepath, 'wb') as up:                up.write(meta['body'])            ret = {'result': '1'}            Result = json.dumps(ret)            self.write(Result)# ========增加代码--开始========def produce_stop_bat(pid, tmpfile="stop_xxx.bat"):    # 待写入内容    stop_cmd = 'taskkill /pid ' + str(pid) + ' /f'  # 关闭指定进程    del_self_cmd = "del %0"  # 删除自身文件    # 文件路径和名称    tmp_all = os.path.join(os.path.dirname(os.path.realpath(__file__)), "stop_" + tmpfile + ".bat")    # 写入文件    with open(file=tmp_all, mode="w") as f:        f.write(stop_cmd + "\n" + del_self_cmd)def outputlog():    main_log_handler = logging.FileHandler(log_path +                                           "/DealZip_%s.log" % time.strftime("%Y-%m-%d_%H-%M-%S",                                                                        time.localtime(time.time())), mode="w+",                                           encoding="utf-8")    main_log_handler.setLevel(logging.DEBUG)    formatter = logging.Formatter("%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s")    main_log_handler.setFormatter(formatter)    logger.addHandler(main_log_handler)    # 控制台打印输出日志    console = logging.StreamHandler()  # 定义一个StreamHandler，将INFO级别或更高的日志信息打印到标准错误，并将其添加到当前的日志处理对象    console.setLevel(logging.DEBUG)  # 设置要打印日志的等级，低于这一等级，不会打印    formatter = logging.Formatter("%(asctime)s - %(levelname)s: %(message)s")    console.setFormatter(formatter)    logging.getLogger('').addHandler(console)    # 进程号    pid = os.getpid()    # 本文件名（不含后缀.py）    myfilename = os.path.split(__file__)[-1].split(".")[0]    # 生成关闭进程的脚本文件    produce_stop_bat(pid, myfilename)    # ========增加代码--结束========def main():    application = tornado.web.Application([        (r"/exit_localserver", ExitSystem),        (r'/Ftp/Unzip/', Unzip),        (r'/Ftp/ReadZipPath/', ReadZipPath),  #http://129.204.134.85:8001/Ftp/ReadZipPath/        (r'/Ftp/DealZip/', DealZip),  #http://127.0.0.1:8001/Ftp/DealZip/?filename=%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.zip        (r'/Ftp/UploadFile/', UploadFile),    ], autoreload=True)  # 增加代码有改动，服务器自动重启    template_path = 'templates'    static_path = 'static'    tornado.options.parse_command_line()    http_server = tornado.httpserver.HTTPServer(application)    http_server.listen(options.port)    tornado.ioloop.IOLoop.instance().start()if __name__ == '__main__':    # 如果日志文件夹不存在，则创建    log_dir = "log"  # 日志存放文件夹名称    log_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), log_dir)    if not os.path.isdir(log_path):        os.makedirs(log_path)    print(log_path)    # 设置logging    logger = logging.getLogger()    logger.setLevel(logging.DEBUG)    outputlog()    main()